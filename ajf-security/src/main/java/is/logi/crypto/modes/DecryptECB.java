package is.logi.crypto.modes;

// Copyright (C) 1998 Logi Ragnarsson

import is.logi.crypto.keys.CipherKey;

/**
 * Use this class to decrypt ciphertext generated by EncryptECB.
 * <p>
 * If you are using symmetric keys, the DecryptECB object must be
 * initialized with the same key as the EncryptECB object it is
 * decrypting data from. If you are using asymetric keys, the DecryptECB
 * object must be initialized with the other key from the key-pair.
 *
 * @see is.logi.crypto.modes.EncryptECB
 *
 * @author <a href="http://www.hi.is/~logir/">Logi Ragnarsson</a>
 * (<a href="mailto:logir@hi.is">logir@hi.is</a>)
 */
public class DecryptECB extends DecryptMode{

  /** The key used for decryption. */
  private CipherKey key;
  
  /**
   * <code>buffer[0..bufPos-1]</code> is data waiting to be part of a
   * full block. */
  private byte[] buffer;
  private int bufPos=0;
  
  /**
   * Create a new ECB-mode decrypt session with no key. No decryption
   * can be performed until a call to <code>setKey()</code> has been
   * made.
   */
  public DecryptECB(){
  }
  /** 
   * Create a new ECB-mode decrypt session with the specified key. */
  public DecryptECB(CipherKey key){
    this.key=key;
    buffer = new byte[key.cipherBlockSize()];
  }
  /**
   * Send bytes to the DecryptECB object for decryption.
   * <p>
   * Decrypt <code>length</code> bytes from <code>source</code>,
   * starting at <code>i</code> and return the plaintext. Data may
   * be encrypted in blocks in which case only whole blocks of
   * plaintext are written to <code>dest</code>. Any remaining data
   * will be stored and prepended to <code>source</code> in the next
   * call to <code>decrypt</code>.
   */
  public synchronized byte[] decrypt(byte[] source, int i, int length){
    int ibs=key.cipherBlockSize();
    int obs=key.plainBlockSize();
    
    int blocks = (bufPos+length)/ibs;
    byte[] dest = new byte[blocks*obs];
    int j=0;    // dest[0..j-1] is plaintext
    
    if (bufPos>0){
      // We have unencrypted data in the buffer
      int n=Math.min(length, buffer.length-bufPos);
      System.arraycopy(source,i, buffer,bufPos, n);
      bufPos+=n;
      i+=n;
      length-=n;
      blocks--;
      if (bufPos==buffer.length){
	// We've filled the buffer
	key.decrypt(buffer,0, dest,0);
	j += obs;
	bufPos=0;
      } else
	return dest;  // can't even fill one block...
    }
    int ii=i;
    
    // Encrypt entire blocks
    for (int b=0; b<blocks; b++){
      key.decrypt(source, i, dest, j);
      i+=ibs;
      j+=obs;
    }
    
    // Put possible incomplete block in the buffer
    bufPos = length-(i-ii);
    if(bufPos!=0)
      System.arraycopy(source,i, buffer,0, bufPos);
    
    return dest;
  }
  /** 
   * Return the key used for decryption.
   */
  public CipherKey getKey(){
    return key;
  }
  /**
   * Set the key to use for decryption. Do not call this method when
   * there may be data in the internal buffer.
   */
  public void setKey(CipherKey key){
    this.key=key;
    buffer = new byte[key.plainBlockSize()];
  }
}
