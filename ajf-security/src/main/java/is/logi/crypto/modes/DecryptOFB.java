package is.logi.crypto.modes;

// Copyright (C) 1998 Logi Ragnarsson

import is.logi.crypto.keys.CipherKey;

/**
 * Use this class to decrypt ciphertext generated by EncryptOFB.
 * <p>
 * Note that unlike ECB or CBC mode, OFB mode uses teh <i>same</i>
 * key to encrypt and decrypt, even with asymmetric ciphers.
 *
 * @author <a href="http://www.hi.is/~logir/">Logi Ragnarsson</a>
 * (<a href="mailto:logir@hi.is">logir@hi.is</a>)
 *
 * @see is.logi.crypto.modes.EncryptOFB
 */
public class DecryptOFB extends DecryptMode{

  /** Calculates the stream. */
  private OFBThread thread;

  /** Key to use for encryption. */
  private CipherKey key;
  
  /* Stores desired buffer size until setKey() is called. */
  private int bufSize;

  /* Has IV been read and thread started yet? */
  private boolean gotIV=false;
  
  /**
   * Create a new OFB-mode decrypt session with no key. No
   * encryption can be performed until the <code>setKey()</code>
   * method has been called.
   * <p>
   * A buffer of <code>bufSize</code> bytes is created to hold a
   * pre-calculated xor-stream.*/
  public DecryptOFB(int bufSize){
    this.bufSize=bufSize;
  }
  /**
   * Create a new OFB-mode decrypt session with the specified
   * <code>key</code>. A buffer of <code>bufSize</code> bytes is created
   * to hold a pre-calculated xor-stream.
   */
  public DecryptOFB(CipherKey key, int bufSize){
    this.bufSize=bufSize;
    setKey(key);
  }
  /**
   * Send bytes to the DecryptCFB object for encryption.
   * <p>
   * Decrypt <code>length</code> bytes from <code>source</code>,
   * starting at <code>i</code> and return the plaintext.
   */
  public synchronized byte[] decrypt(byte[] source, int i, int length){

    if (!gotIV){
      thread=new OFBThread(key, bufSize, source,i);
      thread.start();
      while(thread.inBuffer()<=thread.ibs){
        thread.waitForBytes();
      }
      thread.bufStart+=thread.ibs;
      gotIV=true;
      length-=thread.ibs;
      i += thread.ibs;
    }
    byte[] dest = new byte[length];
    int destPos=0;

    while(length>0){
      int n = Math.min(length, thread.inBuffer());
      length-=n;
      int end=i+n;
      while(i<end){
        dest[destPos++] = (byte)(source[i++] ^ thread.buffer[thread.bufStart]);
        // bufStart increased *after* the byte is used,
        // so it isn't overwritten by the calc thread!
        thread.bufStart=(thread.bufStart+1)%thread.bufSize;
      }
      thread.resume();  // We have used some bytes from the buffer, so we'll start calculating
      if(length>0)
        thread.waitForBytes();
    }

    return dest;
  }
  /**
   * Pads the internal buffer, encrypts it and returns the ciphertext.
   * Since CBF mode doesn't use an internal buffer, an empty array is
   * returned. */
  public synchronized byte[] flush(){
    return new byte[0];
  }
  /** Return the key used for encryption. */
  public CipherKey getKey(){
    return key;
  }
  /**
   * Set the key to use for encryption.
   */
  public void setKey(CipherKey key){
    this.key = key;
  }
}
